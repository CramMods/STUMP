using CramMods.NARFI;
using CramMods.NARFI.FieldValueGetters;
using CramMods.NARFI.Skyrim;
using CramMods.STUMP.Settings;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Environments;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace CramMods.STUMP
{
    public class Program
    {
        private static List<string> _testNpcNames = new() { "Narfi", "Gerdur", "Delphine", "Sigrid", "Haelga", "Sven", "Hilde" };

        public static Lazy<VariantSettings> VariantSettings = null!;
        public static Lazy<RaceGroupSettings> RaceGroupSettings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .SetAutogeneratedSettings("Variants", "Variants.json", out VariantSettings, true)
                .SetAutogeneratedSettings("RaceGroups", "RaceGroups.json", out RaceGroupSettings, true)
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "STUMP.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            IGameEnvironmentState<ISkyrimMod, ISkyrimModGetter> env = new GameEnvironmentState<ISkyrimMod, ISkyrimModGetter>(state.GameRelease, state.DataFolderPath, state.LoadOrderFilePath, null, state.LoadOrder, state.LinkCache);

            List<INpcGetter> npcs = state.LoadOrder.PriorityOrder.Npc().WinningOverrides().ToList();
            //npcs = npcs.FindAll(npc => _testNpcNames.Any(name => npc.EditorID?.Equals(name, StringComparison.InvariantCultureIgnoreCase) ?? false));
            List<IRaceGetter> races = state.LoadOrder.PriorityOrder.Race().WinningOverrides().ToList();

            List<RaceGroup> raceGroups = RaceGroupSettings.Value.Flatten(races).ToList();
            List<VariantSettings> variants = VariantSettings.Value.Flatten();

            SkyrimPlugin skyrimPlugin = new();
            skyrimPlugin.SetRaceGroups(raceGroups);

            NARFI.NARFI narfi = new(env);
            narfi.RegisterPlugin(skyrimPlugin);

            Dictionary<INpcGetter, VariantSettings> matches = MatchVariants(npcs, variants, narfi, (total, complete, matched) =>
            {
                if (total != complete) Console.Write($"Matching NPCs...  [ {complete} of {total} ]  {(int)((float)complete / total * 100)} %\r");
                else Console.WriteLine($"\r\nMatched {matched} of {total} NPCs");
            });
            List<VariantSettings> distinctVariants = matches.Values.DistinctBy(v => v.ToString()).ToList();
            Console.WriteLine($"There are {distinctVariants.Count} distinct variants");
            Console.WriteLine();

            Console.WriteLine();
            Console.WriteLine("Press any key to exit");
            Console.ReadKey();
        }

        private static Dictionary<INpcGetter, VariantSettings> MatchVariants(IEnumerable<INpcGetter> npcs, IEnumerable<VariantSettings> variants, IFieldValueGetter fieldValueGetter, MatchVariantsCallback? callback = null)
        {
            Dictionary<INpcGetter, VariantSettings> output = new();
            int total = npcs.Count();
            int current = 0;
            int matchCount = 0;

            foreach (INpcGetter npc in npcs)
            {
                if (callback != null) callback.Invoke(total, ++current, matchCount);

                IEnumerable<VariantSettings> matchingVariants = variants.Where(v => v.Filter?.Test(npc, fieldValueGetter) ?? false);
                if (matchingVariants.Count() == 0) continue;

                int maxForce = matchingVariants.Max(v => v.ForceCount);
                matchingVariants = matchingVariants.Where(v => v.ForceCount == maxForce);
                if (matchingVariants.Count() == 0) continue;

                output.Add(npc, SelectRandomVariant(matchingVariants));
                matchCount++;
            }
            if (callback != null) callback.Invoke(total, current, matchCount);

            return output;
        }
        private delegate void MatchVariantsCallback(int total, int complete, int matchCount);

        private static VariantSettings SelectRandomVariant(IEnumerable<VariantSettings> variants)
        {
            float total = variants.Sum(v => v.Weighting);
            float random = new Random().NextSingle() * total;
            float next = 0.0F;

            foreach (VariantSettings variant in variants)
            {
                next += variant.Weighting;
                if (next >= random) return variant;
            }

            throw new Exception("Something went wrong. Shouldn't be possible");
        }
    }
}
